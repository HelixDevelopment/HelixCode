package config

import (
	"os"
	"path/filepath"
	"testing"

	"dev.helix.code/internal/database"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestLoad(t *testing.T) {
	// Create a temporary config file for testing
	tempDir := t.TempDir()
	configPath := filepath.Join(tempDir, "config.yaml")

	configContent := `
server:
  address: "0.0.0.0"
  port: 8080
auth:
  jwt_secret: "test-jwt-secret-for-testing"
database:
  host: "localhost"
  dbname: "test"
redis:
  enabled: false
`

	err := os.WriteFile(configPath, []byte(configContent), 0644)
	require.NoError(t, err)

	// Clear any environment variables that might override config file
	oldJWTSecret := os.Getenv("HELIX_AUTH_JWT_SECRET")
	defer func() {
		if oldJWTSecret != "" {
			os.Setenv("HELIX_AUTH_JWT_SECRET", oldJWTSecret)
		} else {
			os.Unsetenv("HELIX_AUTH_JWT_SECRET")
		}
	}()
	os.Unsetenv("HELIX_AUTH_JWT_SECRET")

	// Set config path environment variable
	oldHelixConfig := os.Getenv("HELIX_CONFIG")
	defer os.Setenv("HELIX_CONFIG", oldHelixConfig)
	os.Setenv("HELIX_CONFIG", configPath)

	// Test loading config
	cfg, err := Load()
	require.NoError(t, err)
	assert.NotNil(t, cfg)
	assert.Equal(t, "0.0.0.0", cfg.Server.Address)
	assert.Equal(t, 8080, cfg.Server.Port)
	assert.Equal(t, "test-jwt-secret-for-testing", cfg.Auth.JWTSecret)
}

func TestValidateHelixConfig(t *testing.T) {
	tests := []struct {
		name    string
		config  Config
		wantErr bool
	}{
		{
			name: "valid config",
			config: HelixConfig{
				Server: ServerHelixConfig{Port: 8080},
				Database: database.HelixConfig{
					Host:   "localhost",
					DBName: "test",
				},
				Redis: RedisHelixConfig{
					Host:    "localhost",
					Port:    6379,
					Enabled: true,
				},
				Auth: AuthHelixConfig{
					JWTSecret: "test-secret",
				},
				Workers: WorkersHelixConfig{
					HealthCheckInterval: 30,
					MaxConcurrentTasks:  10,
				},
				Tasks: TasksHelixConfig{
					MaxRetries: 3,
				},
				LLM: LLMHelixConfig{
					MaxTokens:   4096,
					Temperature: 0.7,
				},
			},
			wantErr: false,
		},
		{
			name: "invalid server port",
			config: HelixConfig{
				Server: ServerHelixConfig{Port: 99999},
			},
			wantErr: true,
		},
		{
			name: "missing database host",
			config: HelixConfig{
				Server: ServerHelixConfig{Port: 8080},
				Database: database.HelixConfig{
					DBName: "test",
				},
			},
			wantErr: true,
		},
		{
			name: "default JWT secret",
			config: HelixConfig{
				Server: ServerHelixConfig{Port: 8080},
				Database: database.HelixConfig{
					Host:   "localhost",
					DBName: "test",
				},
				Auth: AuthHelixConfig{
					JWTSecret: "default-secret-change-in-production",
				},
			},
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := validateHelixConfig(&tt.config)
			if tt.wantErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
		})
	}
}

func TestFindHelixConfigFile(t *testing.T) {
	// Test with environment variable
	tempDir := t.TempDir()
	configPath := filepath.Join(tempDir, "test-config.yaml")
	err := os.WriteFile(configPath, []byte("test: content"), 0644)
	require.NoError(t, err)

	oldValue := os.Getenv("HELIX_CONFIG")
	defer os.Setenv("HELIX_CONFIG", oldValue)

	os.Setenv("HELIX_CONFIG", configPath)
	found := findHelixConfigFile()
	assert.Equal(t, configPath, found)
}

func TestCreateDefaultHelixConfig(t *testing.T) {
	tempDir := t.TempDir()
	configPath := filepath.Join(tempDir, "config.yaml")

	err := CreateDefaultHelixConfig(configPath)
	assert.NoError(t, err)

	// Check if file exists
	_, err = os.Stat(configPath)
	assert.NoError(t, err)

	// Check content
	content, err := os.ReadFile(configPath)
	require.NoError(t, err)
	assert.Contains(t, string(content), "server:")
	assert.Contains(t, string(content), "database:")
	assert.Contains(t, string(content), "redis:")
}

func TestGetEnvOrDefault(t *testing.T) {
	// Test with existing env var
	os.Setenv("TEST_VAR", "test_value")
	defer os.Unsetenv("TEST_VAR")

	assert.Equal(t, "test_value", GetEnvOrDefault("TEST_VAR", "default"))

	// Test with non-existing env var
	assert.Equal(t, "default", GetEnvOrDefault("NON_EXISTING_VAR", "default"))
}

func TestGetEnvIntOrDefault(t *testing.T) {
	// Test with existing env var
	os.Setenv("TEST_INT_VAR", "42")
	defer os.Unsetenv("TEST_INT_VAR")

	assert.Equal(t, 42, GetEnvIntOrDefault("TEST_INT_VAR", 10))

	// Test with non-existing env var
	assert.Equal(t, 10, GetEnvIntOrDefault("NON_EXISTING_INT_VAR", 10))

	// Test with invalid value
	os.Setenv("TEST_INVALID_INT", "not_a_number")
	defer os.Unsetenv("TEST_INVALID_INT")

	assert.Equal(t, 10, GetEnvIntOrDefault("TEST_INVALID_INT", 10))
}

// TestLoad_NoHelixConfigFile tests loading config when no config file exists
func TestLoad_NoHelixConfigFile(t *testing.T) {
	// Set JWT secret via env var to pass validation
	oldJWTSecret := os.Getenv("HELIX_AUTH_JWT_SECRET")
	defer func() {
		if oldJWTSecret != "" {
			os.Setenv("HELIX_AUTH_JWT_SECRET", oldJWTSecret)
		} else {
			os.Unsetenv("HELIX_AUTH_JWT_SECRET")
		}
	}()
	os.Setenv("HELIX_AUTH_JWT_SECRET", "test-secret-for-no-config")

	// Ensure HELIX_CONFIG points to non-existent file
	oldHelixConfig := os.Getenv("HELIX_CONFIG")
	defer os.Setenv("HELIX_CONFIG", oldHelixConfig)
	os.Setenv("HELIX_CONFIG", "/tmp/non-existent-config.yaml")

	cfg, err := Load()
	require.NoError(t, err)
	assert.NotNil(t, cfg)
	// Should use defaults
	assert.Equal(t, "0.0.0.0", cfg.Server.Address)
	assert.Equal(t, 8080, cfg.Server.Port)
}

// TestLoad_MalformedHelixConfig tests loading with malformed YAML
func TestLoad_MalformedHelixConfig(t *testing.T) {
	tempDir := t.TempDir()
	configPath := filepath.Join(tempDir, "malformed.yaml")

	// Create malformed YAML
	malformedContent := `
server:
  port: invalid_port
  address: 127.0.0.1
auth:
  jwt_secret: "test-secret"
`
	err := os.WriteFile(configPath, []byte(malformedContent), 0644)
	require.NoError(t, err)

	oldHelixConfig := os.Getenv("HELIX_CONFIG")
	defer os.Setenv("HELIX_CONFIG", oldHelixConfig)
	os.Setenv("HELIX_CONFIG", configPath)

	oldJWTSecret := os.Getenv("HELIX_AUTH_JWT_SECRET")
	defer func() {
		if oldJWTSecret != "" {
			os.Setenv("HELIX_AUTH_JWT_SECRET", oldJWTSecret)
		} else {
			os.Unsetenv("HELIX_AUTH_JWT_SECRET")
		}
	}()
	os.Unsetenv("HELIX_AUTH_JWT_SECRET")

	_, err = Load()
	// Should fail to unmarshal
	assert.Error(t, err)
}

// TestLoad_EnvironmentOverrides tests environment variable overrides
func TestLoad_EnvironmentOverrides(t *testing.T) {
	tempDir := t.TempDir()
	configPath := filepath.Join(tempDir, "config.yaml")

	configContent := `
server:
  port: 8080
database:
  host: "localhost"
  port: 5432
  dbname: "testdb"
auth:
  jwt_secret: "file-secret"
redis:
  enabled: false
`
	err := os.WriteFile(configPath, []byte(configContent), 0644)
	require.NoError(t, err)

	// Set environment overrides
	oldHelixConfig := os.Getenv("HELIX_CONFIG")
	oldDBHost := os.Getenv("HELIX_DATABASE_HOST")
	oldDBPort := os.Getenv("HELIX_DATABASE_PORT")
	oldJWTSecret := os.Getenv("HELIX_AUTH_JWT_SECRET")

	defer func() {
		os.Setenv("HELIX_CONFIG", oldHelixConfig)
		os.Setenv("HELIX_DATABASE_HOST", oldDBHost)
		os.Setenv("HELIX_DATABASE_PORT", oldDBPort)
		if oldJWTSecret != "" {
			os.Setenv("HELIX_AUTH_JWT_SECRET", oldJWTSecret)
		} else {
			os.Unsetenv("HELIX_AUTH_JWT_SECRET")
		}
	}()

	os.Setenv("HELIX_CONFIG", configPath)
	os.Setenv("HELIX_DATABASE_HOST", "db.example.com")
	os.Setenv("HELIX_DATABASE_PORT", "5433")
	os.Setenv("HELIX_AUTH_JWT_SECRET", "env-secret")

	cfg, err := Load()
	require.NoError(t, err)
	assert.Equal(t, "db.example.com", cfg.Database.Host)
	assert.Equal(t, 5433, cfg.Database.Port)
	assert.Equal(t, "env-secret", cfg.Auth.JWTSecret)
}

// TestFindHelixConfigFile_NonExistent tests findHelixConfigFile with non-existent path
func TestFindHelixConfigFile_NonExistent(t *testing.T) {
	oldValue := os.Getenv("HELIX_CONFIG")
	defer os.Setenv("HELIX_CONFIG", oldValue)

	os.Setenv("HELIX_CONFIG", "/tmp/does-not-exist.yaml")
	found := findHelixConfigFile()
	assert.Empty(t, found)
}

// TestFindHelixConfigFile_EmptyEnvVar tests findHelixConfigFile with empty env var
func TestFindHelixConfigFile_EmptyEnvVar(t *testing.T) {
	oldValue := os.Getenv("HELIX_CONFIG")
	defer os.Setenv("HELIX_CONFIG", oldValue)

	os.Setenv("HELIX_CONFIG", "")
	found := findHelixConfigFile()
	// Should return empty since no config files exist in default locations
	assert.Empty(t, found)
}

// TestValidateHelixConfig_EdgeCases tests all validation edge cases
func TestValidateHelixConfig_EdgeCases(t *testing.T) {
	tests := []struct {
		name    string
		config  HelixConfig
		wantErr bool
		errMsg  string
	}{
		{
			name: "missing database name",
			config: HelixConfig{
				Server: ServerHelixConfig{Port: 8080},
				Database: database.HelixConfig{
					Host: "localhost",
				},
				Redis: RedisHelixConfig{Enabled: false},
				Auth:  AuthHelixConfig{JWTSecret: "test-secret"},
				Workers: WorkersHelixConfig{
					HealthCheckInterval: 30,
					MaxConcurrentTasks:  10,
				},
				Tasks: TasksHelixConfig{MaxRetries: 3},
				LLM: LLMHelixConfig{
					MaxTokens:   4096,
					Temperature: 0.7,
				},
			},
			wantErr: true,
			errMsg:  "database name is required",
		},
		{
			name: "server port zero",
			config: HelixConfig{
				Server: ServerHelixConfig{Port: 0},
			},
			wantErr: true,
			errMsg:  "server port must be between 1 and 65535",
		},
		{
			name: "server port negative",
			config: HelixConfig{
				Server: ServerHelixConfig{Port: -1},
			},
			wantErr: true,
			errMsg:  "server port must be between 1 and 65535",
		},
		{
			name: "redis enabled with missing host",
			config: HelixConfig{
				Server: ServerHelixConfig{Port: 8080},
				Database: database.HelixConfig{
					Host:   "localhost",
					DBName: "test",
				},
				Redis: RedisHelixConfig{
					Enabled: true,
					Port:    6379,
				},
				Auth: AuthHelixConfig{JWTSecret: "test-secret"},
				Workers: WorkersHelixConfig{
					HealthCheckInterval: 30,
					MaxConcurrentTasks:  10,
				},
				Tasks: TasksHelixConfig{MaxRetries: 3},
				LLM: LLMHelixConfig{
					MaxTokens:   4096,
					Temperature: 0.7,
				},
			},
			wantErr: true,
			errMsg:  "redis host is required when redis is enabled",
		},
		{
			name: "redis invalid port zero",
			config: HelixConfig{
				Server: ServerHelixConfig{Port: 8080},
				Database: database.HelixConfig{
					Host:   "localhost",
					DBName: "test",
				},
				Redis: RedisHelixConfig{
					Enabled: true,
					Host:    "localhost",
					Port:    0,
				},
				Auth: AuthHelixConfig{JWTSecret: "test-secret"},
				Workers: WorkersHelixConfig{
					HealthCheckInterval: 30,
					MaxConcurrentTasks:  10,
				},
				Tasks: TasksHelixConfig{MaxRetries: 3},
				LLM: LLMHelixConfig{
					MaxTokens:   4096,
					Temperature: 0.7,
				},
			},
			wantErr: true,
			errMsg:  "redis port must be between 1 and 65535",
		},
		{
			name: "redis disabled should skip validation",
			config: HelixConfig{
				Server: ServerHelixConfig{Port: 8080},
				Database: database.HelixConfig{
					Host:   "localhost",
					DBName: "test",
				},
				Redis: RedisHelixConfig{
					Enabled: false,
					// Missing host and invalid port should be ignored
					Port: 0,
				},
				Auth: AuthHelixConfig{JWTSecret: "test-secret"},
				Workers: WorkersHelixConfig{
					HealthCheckInterval: 30,
					MaxConcurrentTasks:  10,
				},
				Tasks: TasksHelixConfig{MaxRetries: 3},
				LLM: LLMHelixConfig{
					MaxTokens:   4096,
					Temperature: 0.7,
				},
			},
			wantErr: false,
		},
		{
			name: "empty JWT secret",
			config: HelixConfig{
				Server: ServerHelixConfig{Port: 8080},
				Database: database.HelixConfig{
					Host:   "localhost",
					DBName: "test",
				},
				Redis: RedisHelixConfig{Enabled: false},
				Auth:  AuthHelixConfig{JWTSecret: ""},
				Workers: WorkersHelixConfig{
					HealthCheckInterval: 30,
					MaxConcurrentTasks:  10,
				},
				Tasks: TasksHelixConfig{MaxRetries: 3},
				LLM: LLMHelixConfig{
					MaxTokens:   4096,
					Temperature: 0.7,
				},
			},
			wantErr: true,
			errMsg:  "JWT secret must be set",
		},
		{
			name: "invalid health check interval",
			config: HelixConfig{
				Server: ServerHelixConfig{Port: 8080},
				Database: database.HelixConfig{
					Host:   "localhost",
					DBName: "test",
				},
				Redis: RedisHelixConfig{Enabled: false},
				Auth:  AuthHelixConfig{JWTSecret: "test-secret"},
				Workers: WorkersHelixConfig{
					HealthCheckInterval: 0,
					MaxConcurrentTasks:  10,
				},
				Tasks: TasksHelixConfig{MaxRetries: 3},
				LLM: LLMHelixConfig{
					MaxTokens:   4096,
					Temperature: 0.7,
				},
			},
			wantErr: true,
			errMsg:  "health check interval must be positive",
		},
		{
			name: "invalid max concurrent tasks",
			config: HelixConfig{
				Server: ServerHelixConfig{Port: 8080},
				Database: database.HelixConfig{
					Host:   "localhost",
					DBName: "test",
				},
				Redis: RedisHelixConfig{Enabled: false},
				Auth:  AuthHelixConfig{JWTSecret: "test-secret"},
				Workers: WorkersHelixConfig{
					HealthCheckInterval: 30,
					MaxConcurrentTasks:  0,
				},
				Tasks: TasksHelixConfig{MaxRetries: 3},
				LLM: LLMHelixConfig{
					MaxTokens:   4096,
					Temperature: 0.7,
				},
			},
			wantErr: true,
			errMsg:  "max concurrent tasks must be positive",
		},
		{
			name: "negative max retries",
			config: HelixConfig{
				Server: ServerHelixConfig{Port: 8080},
				Database: database.HelixConfig{
					Host:   "localhost",
					DBName: "test",
				},
				Redis: RedisHelixConfig{Enabled: false},
				Auth:  AuthHelixConfig{JWTSecret: "test-secret"},
				Workers: WorkersHelixConfig{
					HealthCheckInterval: 30,
					MaxConcurrentTasks:  10,
				},
				Tasks: TasksHelixConfig{MaxRetries: -1},
				LLM: LLMHelixConfig{
					MaxTokens:   4096,
					Temperature: 0.7,
				},
			},
			wantErr: true,
			errMsg:  "max retries cannot be negative",
		},
		{
			name: "invalid max tokens",
			config: HelixConfig{
				Server: ServerHelixConfig{Port: 8080},
				Database: database.HelixConfig{
					Host:   "localhost",
					DBName: "test",
				},
				Redis: RedisHelixConfig{Enabled: false},
				Auth:  AuthHelixConfig{JWTSecret: "test-secret"},
				Workers: WorkersHelixConfig{
					HealthCheckInterval: 30,
					MaxConcurrentTasks:  10,
				},
				Tasks: TasksHelixConfig{MaxRetries: 3},
				LLM: LLMHelixConfig{
					MaxTokens:   0,
					Temperature: 0.7,
				},
			},
			wantErr: true,
			errMsg:  "max tokens must be positive",
		},
		{
			name: "temperature too low",
			config: HelixConfig{
				Server: ServerHelixConfig{Port: 8080},
				Database: database.HelixConfig{
					Host:   "localhost",
					DBName: "test",
				},
				Redis: RedisHelixConfig{Enabled: false},
				Auth:  AuthHelixConfig{JWTSecret: "test-secret"},
				Workers: WorkersHelixConfig{
					HealthCheckInterval: 30,
					MaxConcurrentTasks:  10,
				},
				Tasks: TasksHelixConfig{MaxRetries: 3},
				LLM: LLMHelixConfig{
					MaxTokens:   4096,
					Temperature: -0.1,
				},
			},
			wantErr: true,
			errMsg:  "temperature must be between 0 and 2",
		},
		{
			name: "temperature too high",
			config: HelixConfig{
				Server: ServerHelixConfig{Port: 8080},
				Database: database.HelixConfig{
					Host:   "localhost",
					DBName: "test",
				},
				Redis: RedisHelixConfig{Enabled: false},
				Auth:  AuthHelixConfig{JWTSecret: "test-secret"},
				Workers: WorkersHelixConfig{
					HealthCheckInterval: 30,
					MaxConcurrentTasks:  10,
				},
				Tasks: TasksHelixConfig{MaxRetries: 3},
				LLM: LLMHelixConfig{
					MaxTokens:   4096,
					Temperature: 2.1,
				},
			},
			wantErr: true,
			errMsg:  "temperature must be between 0 and 2",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := validateHelixConfig(&tt.config)
			if tt.wantErr {
				assert.Error(t, err)
				if tt.errMsg != "" {
					assert.Contains(t, err.Error(), tt.errMsg)
				}
			} else {
				assert.NoError(t, err)
			}
		})
	}
}

// TestCreateDefaultHelixConfig_DirectoryCreation tests directory creation
func TestCreateDefaultHelixConfig_DirectoryCreation(t *testing.T) {
	tempDir := t.TempDir()
	configPath := filepath.Join(tempDir, "nested", "path", "config.yaml")

	err := CreateDefaultHelixConfig(configPath)
	assert.NoError(t, err)

	// Check if file and directories were created
	_, err = os.Stat(configPath)
	assert.NoError(t, err)

	// Verify content
	content, err := os.ReadFile(configPath)
	require.NoError(t, err)
	assert.Contains(t, string(content), "HelixCode Server HelixConfiguration")
}
